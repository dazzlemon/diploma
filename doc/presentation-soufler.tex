\documentclass{article}
\usepackage{polyglossia}
\usepackage{titlesec}

\setdefaultlanguage{ukrainian}
\setotherlanguage{english}

\newfontfamily{\cyrillicfont}{Times New Roman}

\let\oldsection\section
\renewcommand{\section}{\clearpage\oldsection}

\setlength{\parskip}{10pt}
\setlength{\parindent}{0pt}

\begin{document}

\section{Title}
Я \textemdash~ Сафонов Данило,\\
тема \textemdash~
розробка засобів підбору та перевірки коректності УДК-шифрів наукових робіт.

\section{Популярність УДК}
На слайді наведено докази популярності системи УДК \textemdash~
універсальної десяткової класифікації.
Ця популярність обгрунтована декількома причинами.

По-перше, ця система намагаєтся охопити усі знання людства, тобто є універсальною
\textemdash~ її можна використовувати у бібліотека з будь-якими типами текстів.

По-друге, завдяки своєму синтаксису вона дозволяє описувати складні відносини
між різними темами, які можуть бути скомбіновані в одному тексті.
Разом із першим пунктом, це дозволяє класифікувати усі можливі тексти.

В третіх, система підтримує більше 50 мов текстів.
Таким чином можна класифікувати будь-які, навіть складні теми,
на великій кількості популярних мов.

Четвертою причиною можна вважати активну підтримку систему.

Загалом, ця система дозволяє організовувати великі об'єми текстів,
і робити це єффективно та стандартизовано, з можливістю подальшого розширення.

\section{Складнощі використання УДК}
Як я вже казав на попередньому слайді, ця система намагаєтся класифікувати
усі різні типи текстів, та комбінції їх тем.
З цього отримуємо дуже складну систему:
\begin{itemize}
  \item 9 класів, поділені на більш ніж 60,000 підкласів;
  \item 10 синтаксичних поширень та 6 поєднувальних символів,
	  вони дозволяють комбінувати підкласи для текстів які охоплюють декілька тем одразу,
		а це більшість.
\end{itemize}

Крім того, через те що дуже багато текстів насправді відносятся до декількох тем,
шифри текстів можуть виходити дуже довгими.

З цього виходить що система може бути використана тільки тренованими працівниками,
і навіть тоді це будє займати вагомий час.

\subsection{Summary}
Тож ми маємо дуже популярний і сильний інструмент, алє в той самий час,
використання цього інструменту вимагає додаткового тренування та займає багато часу.
Тобто автоматизуючий ці процеси, навіть частково, буде зєкономлено багато ресурсів.

\section{Use-case}
Повністю автоматизувати такий процес можливо,
алє така робота займе дуже багато часу, і навіть тоді доцільно мати персонал,
який буде наглядати за роботою автоматизованого інструменту та перевіряти результати.

Для даної роботи було вирішено дозволити користувачу запитувати в програми класи УДК,
а також порівнювати результат наданий програмою із тим що надав користувач.

Цю проблему не можна вирішити суто алгоритмічно, через те що може існувати безліч текстів,
різної довжини, мови тощо.
Для вирішення проблеми мови, у межах цієї роботи розглядаются тільки
наукові роботи англійською мовою, алє розроблений додаток можна використовувати
і з текстами на інших мовах.

Проблема різних довжин та безлічі текстів буде вирішена підходом до вирішення проблеми 
\textemdash~ машинним навчанням.
Через це з'являєтся ще один сценарій використання \textemdash~ тренування.
Тож треба виділити окремого користувача \textemdash~ розробника, який буде заповнювати модель даними.
Наприклад бібліотека може натреновувати модель, а користувачи при додаванні своїх робіт,
зможуть використовувати додаток, для спрошення процесу створення УДК-шифру.
Якщо брати як приклад бібліотекаря, він скоріш за все буде охоплювати обидва типи користувачів.

\section{Архітектура}
Архітектура була розроблена покроково, одночасно із реалізацією.
Це дозволило бачити прогрес розробки якомого швидше.

Перша ітерація була дуже простою \textemdash~ програму було розділено на два модулі:
\begin{itemize}
\item main, який відповідає за користувацький інтерфейс;
\item та backend, в якому будуть усі алгоритми.
\end{itemize}

На даному єтапі ці модулі були реалізовані лише як заглушки.

\section{Архітектура. Модуль користувацького інтерфейсу}
В другій ітерації було вирішено виділити окремий модуль, відповідальний за користувацький інтерфейс,
а модуль Main буде відповідати лише за спілкування між іншими модулями,
та буде служити вхідною точкою програми.

Виділення окремого модуля користувацького інтерфейсу
дає можливість розробити на тій самій кодовій базі інші типи користувацького інтерфейсу. 

\section{Архітектура. Режими роботи додатку}
У наступній ітерації замість взаємовиключних булевих полів було введено клас Mode
та його підкласи. Насправді, на даному єтапі це просте перечисленя,
алє через те що архітектура змодельована з використанням UML, це представле ієрархією класів.

Ця зміна робить інтерфейс класу UDCArgparser простішим для використання.
Крім того, нове перечислення можна використовувати й у інших модулях додатку,
таким чином значно спрошуючи кодову базу.

\section{Архітектура. Режими роботи додатку. SRP}
В цій ітерації, перечислення, яке було виділено у попередній ітерації,
було перетворено на алгебраічний тип даних. Тобто маємо один тип даних,
який може приймати декілька окремих множин значень. Знову ж це представлено ієрархію класів.

Ця зміна переносить відповідальність представлення режиму роботи повністю
до типу Mode та його підкласів, а UDCArgParser тепер відповідальний лише за
розшифровку вхідних даних, а самє аргументів командного рядка.

Ця зміна відповідає принципу єдиної відповідальності,
який обозначаєтся англійською літерою S в філософії розробки SOLID.

\section{Архітектура. Абстракція типів вхідних даних}
В наступній ітерації важливою зміною є виділення типів для представлення вхідних даних.
Завдяки цьому усі можливі зміни до типів вхідних даних можна буде зробити в одному місці
, тобто централізовано.

\section{Фінальна архітектура}
В останній версії було додано модуль UdcCode, який відповідає за представлення
класів УДК та їх порівняння. Також залежність від UdcPredictorTextInput
та UdcPredictorModel було перенесено до модуля Backend.
Тепер UdcArgParser лише зчитує імена файлів, а саме читання файлів відбуваєтся
в модулі Main.

Завдяки цій зміні робота із файлами повністю відбуваєтся модулі Main.
Крім того, додаток тепер відповідає принципу Resource acquisition is initialization.
Раніше було порушення цього принципу, UDCArgParser відкривав файли, 
а їх використання та закриття відбувалося в інших модулях.

\subsection{Suggestions}
Додатково, для наступної ітерації можна запропонувати покращенння \textemdash~
виділення окремого модуля, який буде зчитувати файли, додаткової проміжної
версії представлення режиму роботи.

Таким чином ми будемо мати два окремих рівня інтерфейсу,
а клас Main у свою чергу не буде знати про існування файлів, тощо.
Це знову ж спрощує додавання, наприклад, графічного інтерфейсу,
або використання цього додатку для створення веб-сторінки, і так далі.

\section{Засоби програмування}

\subsection{Python}
Мову програмування Python було обрано з декількох причин.

По-перше, ця мова одна з найпопулярніших протягом багатьох років,
і ця популярність тільки росте.
Завдяки цьому маємо велике і дуже активне суспільство.
Від цього ми отримуємо безліч різних бібліотек та інструментів, іншу підтримку мови.
Також, через таку популярність і велике суспільство,
можна дуже просто найти рішення для багатьох проблем.
За це можна подякувати також вік мови \textemdash~
завдяки тому що мова відносно немолода, вона була використана дуже багато разів,
великою кількістю розробників.

Із безлічи бібліотек, доступних на цій мові, також присутні
і такі для обробки натуральних текстів. Більш того, ця мова є однією з
найпопулярніших у цьому напрямі.

\subsection{spaCy}

Бібліотеку spaCy було обрано після порівняння з іншими популярними рішеннями.

Деякі інши варіанти потребували попереднього тренування, коли spaCy надає
готові моделі на англійській мові.

Інші були простіші за функціоналом та/або повільніші за spaCy.

Деякі мали простіші алгоритми, або не мали деякі з необхідних зовсім.

Хоча spaCy і не надає готового рішення,
ця бібліотека надає широкий функціонал, який дозволяє вирішити проблеми,
поставлені цією роботою простим шляхом, з можливістю подальшого вдосконалення.

\section{Вибір формату серіалізації}
Для вибору формату серіалізації було створено таку таблицю.
Дані були взяті з оглядової статті та перетворенні на щільнішу таблицю.

Стаття, з якої взято дані надавала більше характеристик.
Деякі з них були відкинуті через схожість з іншими (і по сенсу і по числовій оцінці).
Інші не були важливими для розглянутого сценарію використання.

\begin{itemize}
\item Підтримка мов програмування є важливою для можливості розробки розширень
  на інших мовах, або переведення додатку на іншу мову, тощо.
\item Читабельність важлива для спрошення відладки.
\item Структура даних важлива для можливого ускладнення моделі вподальшому.
\item Стандартизація має мати високу оцінку для того щоб наш сценарій
  розглядання підтримки мов програмування мав сенс.
\end{itemize}

\hrulefill

\begin{itemize}
	\item CSV відкинуто через погані стандартизацію та структуру даних.
	\item Protobuf через нечитабельність.
	\item JSON через погану читабельність та не дуже структуру даних.
	\item XML також має погану читабельність.
	\item із TOML та YAML було обрано TOML через схожість синтаксису із обраною мовою,
	та дуже високу оцінку по іншим характеристикам.
	Не дуже підтримку мов програмування можна, за необхідності,
	вирішити перекладачами між мовами серіалізації.
\end{itemize}

\section{Алгоритм витягування ключових слів з тексту}
	spaCy надає нам усі іменникові групи, які є у тексті. Далі
\begin{itemize}
  \item з іменникових груп видаляются знаки пунктуації;
  \item відкидуются ті групи, в яких є стоп-слова;
  \item видаляются занадто короткі групи;
  \item обираются ті групи, які зустрічаются найчастіше.
\end{itemize}


\section{Алгоритм перетворення ключових слів на класи УДК}
% TODO: shoto pro model'

Тут $F$ \textemdash~ ключові слова (та кількість їх використань),
      які були підібрані програмою та присутні у списку, який надав користувач;

  $K_p$ \textemdash~ ключові слова підібрані програмою;

  $K_u$ \textemdash~ ключові слова надані користувачем;

  $n(k,~ K)$ \textemdash~ скільки разів $k$ зустрічаєтся в $K$;

  $M$ \textemdash~ старе значення моделі (такий самий формат я і в $F$);

  $M'$ \textemdash~ нове значення моделі;

  $f'$ \textemdash~ будь-яке значення f (wildcard).

  Далі для кожного з класів УДК, наданих користувачем,
  додамо до моделі запис для кожного з залишившихся ключових слів із цим класом,
  ключовим словом, та кількістю використань цього слова.
  Якщо запис із таким класом та ключовим словом вже присутній ---
  просто збільшуємо лічильник використань такого ключового слова.

\section{Порівняння списків класів УДК}
Для скорочення часу розробки було вирішено спростити функціонал додатку,
  та замість шифрів УДК приймати класи УДК.
  Крім скорочення часу розробки, це також дозволяє використовувати програму
  із будь-якими системами класифікації,
  що у свою чергу є розширенням функціоналу.

  Через те що ключові слова є множиною, вирішено використати простий спосіб
  порівняння --- коефіцієнт Жаккара .
  Ця формула порівнює схожість двух скінченних множин та представляє собою
  частку від ділення розміру перетину 
  на розмір об'єднання  двох множин.
  Результатом є число від нуля до одиніці, нуль зустрічаєтся
  у тих випадках коли множини не мають жодного спільного єлемента,
  а одиниця означає що множини однакові.
  Таким чином програма буде відповідати значеннями від нуля до одиниці,
  і чим више значення тим вище співпадіння між класами УДК,
  які обрав користувач та тими, що пропонує програма.

  Такий функціонал дозволить не порівнювати обидва списки вручну,
  а просто подивитися на результат порівняння, і якщо похибка не є вагомою,
  на думку користувача, він може використати будь-який з двох списків або обидва.

\section{Результати роботи}
TODO:

\section{Висновки}
TODO:

\end{document}
